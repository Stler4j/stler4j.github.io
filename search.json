[{"title":"LeetCode第400场周赛","path":"/2024/06/02/算法/LeetCode/周赛/LeetCode第400场周赛/","content":"https://leetcode.cn/contest/weekly-contest-400 2. 无需开会的工作日class Solution &#123; List&lt;int[]&gt; merge(int[][] intervals) &#123; Arrays.sort(intervals, Comparator.comparingInt(interval -&gt; interval[0])); List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); for (int[] interval : intervals) &#123; int m = ans.size(); int l = interval[0], r = interval[1]; if (ans.isEmpty() || ans.get(m - 1)[1] &lt; l) &#123; ans.add(new int[] &#123; l, r &#125;); &#125; else &#123; ans.get(m - 1)[1] = Math.max(ans.get(m - 1)[1], r); &#125; &#125; return ans; &#125; public int countDays(int days, int[][] meetings) &#123; List&lt;int[]&gt; merged = merge(meetings); for (int[] meeting : merged) &#123; int l = meeting[0], r = meeting[1]; days -= r - l + 1; &#125; return days; &#125; &#125; 3. 删除星号以后字典序最小的字符串class Solution &#123; public String clearStars(String s) &#123; int n = s.length(); Deque&lt;Integer&gt;[] indices = IntStream.range(0, 26).boxed().map(_ -&gt; new ArrayDeque&lt;&gt;()).toArray(Deque[]::new); boolean[] deleted = new boolean[n]; for (int i = 0; i &lt; n; ++i) &#123; char c = s.charAt(i); if (c == &#39;*&#39;) &#123; for (int j = 0; j &lt; 26; ++j) &#123; if (!indices[j].isEmpty()) &#123; int index = indices[j].pop(); deleted[index] = true; break; &#125; &#125; &#125; else &#123; indices[c - &#39;a&#39;].push(i); &#125; &#125; StringBuilder ans = new StringBuilder(); for (int i = 0; i &lt; n; ++i) &#123; char c = s.charAt(i); if (c != &#39;*&#39; &amp;&amp; !deleted[i]) &#123; ans.append(c); &#125; &#125; return ans.toString(); &#125; &#125; 4. 找到按位与最接近 K 的子数组枚举$\\leq r$的不同零的位置。 class Solution &#123; static int B = 30; public int minimumDifference(int[] nums, int k) &#123; int n = nums.length; int[][] last = new int[n][B]; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; B; ++j) &#123; int x = nums[i] &gt;&gt; j &amp; 1; if (i == 0) &#123; last[i][j] = x == 0 ? 0 : -1; &#125; else &#123; last[i][j] = x == 0 ? i : last[i - 1][j]; &#125; &#125; &#125; int ans = Integer.MAX_VALUE; for (int i = 0; i &lt; n; ++i) &#123; List&lt;Integer&gt; indices = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; B; ++j) &#123; if (last[i][j] &gt;= 0) &#123; indices.add(last[i][j]); &#125; &#125; indices.sort(Comparator.comparingInt(Integer::intValue).reversed()); int res = nums[i]; ans = Math.min(ans, Math.abs(res - k)); for (int index : indices) &#123; res &amp;= nums[index]; ans = Math.min(ans, Math.abs(res - k)); &#125; &#125; return ans; &#125; &#125;","tags":["位运算"],"categories":["LeetCode","周赛"]},{"title":"软件/VSCode","path":"/2024/06/02/软件/VSCode/","content":"软件设置界面C:/Program Files/Microsoft VS Code/resources/app/out/vs/workbench/workbench.desktop.main.css /* windows全局字体 */ .windows &#123; font-family: AaBiaoTiChuYuan, Segoe WPC, Segoe UI, sans-serif &#125; .windows:lang(zh-Hans) &#123; font-family: AaBiaoTiChuYuan, Segoe WPC, Segoe UI, Microsoft YaHei, sans-serif &#125; .windows:lang(zh-Hant) &#123; font-family: AaBiaoTiChuYuan, Segoe WPC, Segoe UI, Microsoft Jhenghei, sans-serif &#125; .windows:lang(ja) &#123; font-family: AaBiaoTiChuYuan, Segoe WPC, Segoe UI, Yu Gothic UI, Meiryo UI, sans-serif &#125; .windows:lang(ko) &#123; font-family: AaBiaoTiChuYuan, Segoe WPC, Segoe UI, Malgun Gothic, Dotom, sans-serif &#125; /* 右键菜单 */ .shadow-root-host &#123; font-family: AaBiaoTiChuYuan; &#125; 配置文件&#123; // 隐藏菜单(按Alt显示) &quot;window.menuBarVisibility&quot;: &quot;toggle&quot;, // 隐藏命令中心 &quot;window.commandCenter&quot;: false, // 一级侧边栏置于子级侧边栏上方 &quot;workbench.activityBar.location&quot;: &quot;top&quot;, // 隐藏底部状态栏 &quot;workbench.statusBar.visible&quot;: false, // 隐藏布局工具 &quot;workbench.layoutControl.enabled&quot;: false, // 文件图标主题 &quot;workbench.iconTheme&quot;: &quot;material-icon-theme&quot;, // 树形视图缩进 &quot;workbench.tree.indent&quot;: 20, // 编辑器字体 &quot;editor.fontFamily&quot;: &quot;Monaco&quot;, // 编辑器字体大小 &quot;editor.fontSize&quot;: 19, // 编辑器顶部隐藏导航 &quot;editor.stickyScroll.enabled&quot;: false, // 代码缩略图 &quot;editor.minimap.autohide&quot;: true, // 显示尾随空格 &quot;editor.renderWhitespace&quot;: &quot;trailing&quot;, // 代码换行 &quot;editor.wordWrap&quot;: &quot;on&quot;, // 路径导航 &quot;breadcrumbs.enabled&quot;: false, // 取消资源管理器自动定位文件 &quot;explorer.autoReveal&quot;: false, // 终端字体 &quot;terminal.integrated.fontSize&quot;: 19, // 终端光标样式 &quot;terminal.integrated.cursorStyle&quot;: &quot;line&quot;, // 文件自动保存 &quot;files.autoSave&quot;: &quot;afterDelay&quot;, // 保存时删除尾随空格 &quot;files.trimTrailingWhitespace&quot;: true, // 隐藏扩展建议 &quot;extensions.ignoreRecommendations&quot;: true, // 始终打开非信任文件 &quot;security.workspace.trust.untrustedFiles&quot;: &quot;open&quot;, &#125; 插件// 汉化包 MS-CEINTL.vscode-language-pack-zh-hans // idea快捷键 k--kato.intellij-idea-keybindings // 实时更新 ritwickdey.LiveServer // 文件图标 PKief.material-icon-theme // 主题 monokai.theme-monokai-pro-vscode // Java vscjava.vscode-java-debug redhat.java // 其它语言 sysoev.language-stylus redhat.vscode-yaml Markdown代码片段设置 &gt; 用户代码片段 &gt; markdown.json &#123; &quot;H1&quot;: &#123; &quot;prefix&quot;: &quot;/1&quot;, &quot;body&quot;: [ &quot;# $0&quot; ] &#125;, &quot;H2&quot;: &#123; &quot;prefix&quot;: &quot;/2&quot;, &quot;body&quot;: [ &quot;## $0&quot; ] &#125;, &quot;H3&quot;: &#123; &quot;prefix&quot;: &quot;/3&quot;, &quot;body&quot;: [ &quot;### $0&quot; ] &#125;, &quot;H4&quot;: &#123; &quot;prefix&quot;: &quot;/4&quot;, &quot;body&quot;: [ &quot;#### $0&quot; ] &#125;, &quot;H5&quot;: &#123; &quot;prefix&quot;: &quot;/5&quot;, &quot;body&quot;: [ &quot;##### $0&quot; ] &#125;, &quot;H6&quot;: &#123; &quot;prefix&quot;: &quot;/6&quot;, &quot;body&quot;: [ &quot;###### $0&quot; ] &#125;, &quot;bold粗体&quot;: &#123; &quot;prefix&quot;: &quot;/b&quot;, &quot;body&quot;: [ &quot;**$1**$2&quot; ] &#125;, &quot;italic斜体&quot;: &#123; &quot;prefix&quot;: &quot;/i&quot;, &quot;body&quot;: [ &quot;*$1*$2&quot; ] &#125;, &quot;underline下划线&quot;: &#123; &quot;prefix&quot;: &quot;/u&quot;, &quot;body&quot;: [ &quot;&lt;u&gt;$1&lt;/u&gt;$2&quot; ] &#125;, &quot;line-through删除线&quot;: &#123; &quot;prefix&quot;: &quot;/x&quot;, &quot;body&quot;: [ &quot;~~$1~~$2&quot; ] &#125;, &quot;divider分割线&quot;: &#123; &quot;prefix&quot;: &quot;/d&quot;, &quot;body&quot;: [ &quot;------&quot;, &quot;$1&quot; ] &#125;, &quot;link链接&quot;: &#123; &quot;prefix&quot;: &quot;/k&quot;, &quot;body&quot;: [ &quot;[$2]($1)$3&quot; ] &#125;, &quot;image图片&quot;: &#123; &quot;prefix&quot;: &quot;/img&quot;, &quot;body&quot;: [ &quot;![$2]($1)$3&quot; ] &#125;, &quot;inline code行内代码&quot;: &#123; &quot;prefix&quot;: &quot;/cl&quot;, &quot;body&quot;: [ &quot;`$1`$2&quot; ] &#125;, &quot;code block代码片段&quot;: &#123; &quot;prefix&quot;: &quot;/c&quot;, &quot;body&quot;: [ &quot;```$1&quot;, &quot;$0&quot;, &quot;```&quot; ] &#125;, &quot;ul有序列表&quot;: &#123; &quot;prefix&quot;: &quot;/ul&quot;, &quot;body&quot;: [ &quot;- $0&quot; ] &#125;, &quot;ol无序列表&quot;: &#123; &quot;prefix&quot;: &quot;/ol&quot;, &quot;body&quot;: [ &quot;1. $0&quot; ] &#125;, &quot;task任务列表&quot;: &#123; &quot;prefix&quot;: &quot;/task&quot;, &quot;body&quot;: [ &quot;- [ ] $0&quot; ] &#125;, &quot;quote引用&quot;: &#123; &quot;prefix&quot;: &quot;/q&quot;, &quot;body&quot;: [ &quot;&gt; $1&quot;, &quot;$2&quot; ] &#125;, &quot;table表格&quot;: &#123; &quot;prefix&quot;: &quot;/t&quot;, &quot;body&quot;: [ &quot;| $1 | $2 | $3 | $4 |&quot;, &quot;| ---- | ---- | ---- | ---- |&quot;, &quot;| $5 | $6 | $7 | $8 |&quot;, &quot;| $9 | $10 | $11 | $12 |&quot;, &quot;| $13 | $14 | $15 | $16 |&quot; ] &#125;, &quot;bash代码片段&quot;: &#123; &quot;prefix&quot;: &quot;/bash&quot;, &quot;body&quot;: [ &quot;```bash&quot;, &quot;$0&quot;, &quot;```&quot; ] &#125;, &quot;html代码片段&quot;: &#123; &quot;prefix&quot;: &quot;/html&quot;, &quot;body&quot;: [ &quot;```html&quot;, &quot;$0&quot;, &quot;```&quot; ] &#125;, &quot;js代码片段&quot;: &#123; &quot;prefix&quot;: &quot;/js&quot;, &quot;body&quot;: [ &quot;```js&quot;, &quot;$0&quot;, &quot;```&quot; ] &#125;, &quot;css代码片段&quot;: &#123; &quot;prefix&quot;: &quot;/css&quot;, &quot;body&quot;: [ &quot;```css&quot;, &quot;$0&quot;, &quot;```&quot; ] &#125;, &quot;vue代码片段&quot;: &#123; &quot;prefix&quot;: &quot;/vue&quot;, &quot;body&quot;: [ &quot;```vue&quot;, &quot;$0&quot;, &quot;```&quot; ] &#125;, &quot;java代码片段&quot;: &#123; &quot;prefix&quot;: &quot;/java&quot;, &quot;body&quot;: [ &quot;```java&quot;, &quot;$0&quot;, &quot;```&quot; ] &#125; &#125;","categories":["软件","VSCode"]},{"title":"软件/JetBrains","path":"/2024/06/02/软件/JetBrains/","content":"激活https://3.jetbra.in 选择带*的网址，下载jetbra.zip，解压并运行scripts/install-all-users.vbs。 解压后的文件不可删除，移动位置后需重新执行脚本。 软件设置设置外观与行为 外观 主题：VSCode Dark Modern ☑ 使用自定义字体：AaCuyuan 大小：14 UI选项 ◻ 在主工具栏中使用项目颜色 新UI ☑ 紧凑模式 编辑器 常规 自动导入 Java ☑ 动态添加明确的import 外观 ☑ 对嵌入提示使用编辑器字体 编辑器标签页 打开策略 ☑ 启用预览标签页 代码编辑 移动文本光标时高亮显示 ◻ 匹配大括号 字体 字体：Monaco 大小：19.0 行高：1 代码样式 Java 代码生成 注释代码 ◻ 行注释在第一列 ☑ 在行注释开始处添加空格 ☑ 强制重新格式化 ◻ 注释块在第一列 ☑ 在块注释周围添加空格 HTML 制表符和缩进 ☑ 在&lt;style&gt;和&lt;script&gt;标记内使用HTML缩进 其他 空格 ☑ 在空的标签 在第一个特性前换行：当多行时 在最后一个特性后前换行：当多行时 JavaScript 空格 内部 ☑ 对象文字大括号 ☑ ES6导入/导出大括号 工具 终端 应用程序设置 光标形状：垂直线 插件// 汉化包 13710-chinese-simplified-language-pack // 文件图标 10044-atom-material-icons // 主题 19177-vscode-theme 13643-monokai-pro-theme // 彩色括号 10080-rainbow-brackets // 代码缩略图 18824-codeglance-pro","categories":["软件","JetBrains"]},{"title":"软件/浏览器","path":"/2024/06/02/软件/浏览器/","content":"定时debug检视下拉菜单等元素。 setTimeout(() =&gt; &#123; debugger; &#125;, 2000);","categories":["软件","浏览器"]},{"title":"算法模板/数据结构","path":"/2024/06/02/算法/算法模板/数据结构/","content":"并查集class UnionFindSet &#123; int groups; int[] parent, size; UnionFindSet(int n) &#123; parent = IntStream.range(0, n).toArray(); size = IntStream.range(0, n).map(_ -&gt; 1).toArray(); &#125; int find(int x) &#123; return parent[x] == x ? x : (parent[x] = find(parent[x])); &#125; boolean merge(int x, int y) &#123; if ((x = find(x)) == (y = find(y))) &#123; return false; &#125; parent[x] = y; size[y] += size[x]; --groups; return true; &#125; int sizeOf(int x) &#123; return size[find(x)]; &#125; boolean isLeader(int x) &#123; return x == find(x); &#125; boolean isConnected(int x, int y) &#123; return find(x) == find(y); &#125; &#125; 二维并查集class UnionFindSet2D &#123; int m; UnionFindSet U; UnionFindSet2D(int n, int m) &#123; this.m = m; U = new UnionFindSet(n * m); &#125; int flat(int x, int y) &#123; return m * x + y; &#125; int find(int x, int y) &#123; return U.find(flat(x, y)); &#125; boolean merge(int x1, int y1, int x2, int y2) &#123; return U.merge(flat(x1, y1), flat(x2, y2)); &#125; int sizeOf(int x, int y) &#123; return U.sizeOf(flat(x, y)); &#125; boolean isLeader(int x, int y) &#123; return U.isLeader(flat(x, y)); &#125; boolean isConnected(int x1, int y1, int x2, int y2) &#123; return U.isConnected(flat(x1, y1), flat(x2, y2)); &#125; &#125; 树状数组class FenwickTree &#123; long[] sum, isum; FenwickTree(int n) &#123; sum = new long[n + 5]; isum = new long[n + 5]; &#125; int lowbit(int x) &#123; return x &amp; -x; &#125; void add(int l, int r, long k) &#123; add0(l, k); add0(r + 1, -k); &#125; void add0(int i, long k) &#123; for (int j = i; j &lt; sum.length; j += lowbit(j)) &#123; sum[j] += k; isum[j] += k * i; &#125; &#125; long sum(int l, int r) &#123; return sum0(r) - sum0(l - 1); &#125; long sum0(int i) &#123; long res = 0; for (int j = i; j &gt; 0; j -= lowbit(j)) &#123; res += sum[j] * (i + 1) - isum[j]; &#125; return res; &#125; &#125; 二维树状数组class FenwickTree2D &#123; long[][] t1, t2, t3, t4; FenwickTree2D(int n, int m) &#123; t1 = new long[n + 5][m + 5]; t2 = new long[n + 5][m + 5]; t3 = new long[n + 5][m + 5]; t4 = new long[n + 5][m + 5]; &#125; int lowbit(int x) &#123; return x &amp; -x; &#125; void add(int x1, int y1, int x2, int y2, long k) &#123; add0(x1, y1, k); add0(x1, y2 + 1, -k); add0(x2 + 1, y1, -k); add0(x2 + 1, y2 + 1, k); &#125; void add0(int x, int y, long k) &#123; for (int i = x; i &lt; t1.length; i += lowbit(i)) &#123; for (int j = y; j &lt; t1[0].length; j += lowbit(j)) &#123; t1[i][j] += k; t2[i][j] += k * x; t3[i][j] += k * y; t4[i][j] += k * x * y; &#125; &#125; &#125; long sum(int x1, int y1, int x2, int y2) &#123; return sum0(x2, y2) - sum0(x2, y1 - 1) - sum0(x1 - 1, y2) + sum0(x1 - 1, y1 - 1); &#125; long sum0(int x, int y) &#123; long res = 0; for (int i = x; i &gt; 0; i -= lowbit(i)) &#123; for (int j = y; j &gt; 0; j -= lowbit(j)) &#123; res += t1[i][j] * (x + 1) * (y + 1) - t2[i][j] * (y + 1) - t3[i][j] * (x + 1) + t4[i][j]; &#125; &#125; return res; &#125; &#125; 线段树class XNode &#123; int l, mid, r, len; XNode left, right; XNode(int l, int r) &#123; this.l = l; this.r = r; mid = (l + r) &gt;&gt; 1; len = r - l + 1; &#125; XNode(XNode left, XNode right) &#123; this(left.l, right.r); this.left = left; this.right = right; &#125; void merge() &#123;&#125; void spread() &#123;&#125; void update() &#123;&#125; &#125; class XTree &#123; XNode root; XTree(int n) &#123; root = build(1, n); &#125; XTree(int l, int r) &#123; root = build(l, r); &#125; XNode build(int l, int r) &#123; XNode node = new XNode(l, r); if (l == r) &#123; return node; &#125; node.left = build(l, node.mid); node.right = build(node.mid + 1, r); node.merge(); return node; &#125; void modify(int i) &#123; modify(i, root); &#125; void modify(int i, XNode node) &#123; if (node.l == node.r) &#123; return; &#125; node.spread(); if (i &lt;= node.mid) &#123; modify(i, node.left); &#125; else &#123; modify(i, node.right); &#125; node.merge(); &#125; void modify(int l, int r) &#123; modify(l, r, root); &#125; void modify(int l, int r, XNode node) &#123; if (l &lt;= node.l &amp;&amp; node.r &lt;= r) &#123; return; &#125; node.spread(); if (l &lt;= node.mid) &#123; modify(l, r, node.left); &#125; if (node.mid &lt; r)&#123; modify(l, r, node.right); &#125; node.merge(); &#125; void query(int i) &#123; return query(i, root); &#125; void query(int i, XNode node) &#123; if (node.l == node.r) &#123; return; &#125; node.spread(); if (i &lt;= node.mid) &#123; query(i, node.left); &#125; else &#123; query(i, node.right); &#125; &#125; void query(int l, int r) &#123; return query(l, r, root); &#125; void query(int l, int r, XNode node) &#123; if (l &lt;= node.l &amp;&amp; node.r &lt;= r) &#123; return; &#125; node.spread(); if (l &lt;= node.mid) &#123; query(l, r, node.left); &#125; if (node.mid + 1 &lt;= r) &#123; query(l, r, node.right); &#125; &#125; &#125; 动态开点线段树class EXNode &#123; int l, mid, r, len; EXNode left, right; EXNode(int l, int r) &#123; this.l = l; this.r = r; mid = (l + r) &gt;&gt; 1; len = r - l + 1; &#125; EXNode(EXNode left, EXNode right) &#123; this(left.l, right.r); this.left = left; this.right = right; &#125; void merge() &#123;&#125; void spread() &#123; if (left == null) &#123; left = new EXNode(l, mid); &#125; if (right == null) &#123; right = new EXNode(mid + 1, r); &#125; &#125; void update() &#123;&#125; &#125; class EXTree &#123; EXNode root; EXTree(int n) &#123; root = new EXNode(1, n); &#125; EXTree(int l, int r) &#123; root = new EXNode(l, r); &#125; void modify(int i) &#123; modify(i, root); &#125; void modify(int i, EXNode node) &#123; if (node.l == node.r) &#123; return; &#125; node.spread(); if (i &lt;= node.mid) &#123; modify(i, node.left); &#125; else &#123; modify(i, node.right); &#125; node.merge(); &#125; void modify(int l, int r) &#123; modify(l, r, root); &#125; void modify(int l, int r, EXNode node) &#123; if (l &lt;= node.l &amp;&amp; node.r &lt;= r) &#123; return; &#125; node.spread(); if (l &lt;= node.mid) &#123; modify(l, r, node.left); &#125; if (node.mid + 1 &lt;= r) &#123; modify(l, r, node.right); &#125; node.merge(); &#125; void query(int i) &#123; return query(i, root); &#125; void query(int i, EXNode node) &#123; if (node.l == node.r) &#123; return; &#125; node.spread(); if (i &lt;= node.mid) &#123; query(i, node.left); &#125; else &#123; query(i, node.right); &#125; &#125; void query(int l, int r) &#123; return query(l, r, root); &#125; void query(int l, int r, EXNode node) &#123; if (l &lt;= node.l &amp;&amp; node.r &lt;= r) &#123; return; &#125; node.spread(); if (l &lt;= node.mid) &#123; query(l, r, node.left); &#125; if (node.mid + 1 &lt;= r) &#123; query(l, r, node.right); &#125; &#125; &#125;","categories":["算法模板","数据结构"]},{"title":"算法模板/数学","path":"/2024/06/02/算法/算法模板/数学/","content":"GCD &amp; LCMclass U &#123; static long gcd(long x, long y) &#123; return y == 0 ? x : gcd(y, x % y); &#125; static long lcm(long x, long y) &#123; return x / gcd(x, y) * y; &#125; &#125; 快速幂class U &#123; static long power(long a, long n) &#123; long res = 1; while (n &gt; 0) &#123; if ((n &amp; 1) == 1) &#123; res *= a; &#125; a *= a; n &gt;&gt;= 1; &#125; return res; &#125; static int power(long a, long n, int MOD) &#123; a %= MOD; int res = 1; while (n &gt; 0) &#123; if ((n &amp; 1) == 1) &#123; res = (int) (a * res % MOD); &#125; a = a * a % MOD; n &gt;&gt;= 1; &#125; return res; &#125; &#125; 素数class U &#123; static boolean isPrime(long x) &#123; if (x == 2 || x == 3) &#123; return true; &#125; if ((x % 6 != 1 &amp;&amp; x % 6 != 5) || x == 1) &#123; return false; &#125; for (int i = 5; (long) i * i &lt;= x; i += 6) &#123; if (x % i == 0 || x % (i + 2) == 0) &#123; return false; &#125; &#125; return true; &#125; &#125; 素数筛class Primer &#123; static int N = 100_0005; static boolean[] isPrime = new boolean[N]; static List&lt;Integer&gt; primes = new ArrayList&lt;&gt;(); static &#123; Arrays.fill(isPrime, true); isPrime[1] = false; for (int i = 2; i &lt; N; ++i) &#123; if (isPrime[i]) &#123; primes.add(i); &#125; for (int p : primes) &#123; long k = i * p; if (k &gt;= N) &#123; break; &#125; isPrime[k] = false; if (i % p == 0) &#123; break; &#125; &#125; &#125; &#125; static boolean isPrime(int x) &#123; return isPrime[x]; &#125; &#125; 分解质因数 &amp; 因子class Factor &#123; static List&lt;Pair&lt;Integer, Integer&gt;&gt;[] factorize(int n) &#123; return IntStream.range(0, n + 5).boxed().map(Factor::factorize0).toArray(List[]::new); &#125; static List&lt;Pair&lt;Integer, Integer&gt;&gt; factorize0(int x) &#123; List&lt;Pair&lt;Integer, Integer&gt;&gt; factors = new ArrayList&lt;&gt;(); for (int i = 2; i * i &lt;= x; ++i) &#123; if (x % i == 0) &#123; int cnt = 0; while (x % i == 0) &#123; ++cnt; x /= i; &#125; factors.add(new Pair&lt;&gt;(i, cnt)); &#125; &#125; if (x &gt; 1) &#123; factors.add(new Pair&lt;&gt;(x, 1)); &#125; return factors; &#125; &#125; class Divider &#123; static List&lt;Integer&gt;[] divide(int n) &#123; return IntStream.range(0, n + 5).boxed().map(Divider::divide0).toArray(List[]::new); &#125; static List&lt;Integer&gt; divide0(int x) &#123; List&lt;Integer&gt; divisors = new ArrayList&lt;&gt;(); for (int i = 1; i * i &lt;= x; ++i) &#123; if (x % i == 0) &#123; divisors.add(i); if (i * i &lt; x) &#123; divisors.add(x / i); &#125; &#125; &#125; Collections.sort(divisors); return divisors; &#125; &#125; 组合数class Comb &#123; static int N = 5005; static long[][] f = new long[N][N]; static &#123; for (int i = 1; i &lt; N; ++i) &#123; f[i][0] = f[i][i] = 1; for (int j = 1; j &lt; i; ++j) &#123; f[i][j] = f[i - 1][j - 1] + f[i - 1][j]; &#125; &#125; &#125; static long c(int n, int r) &#123; return f[n][r]; &#125; &#125; 组合数取模class Comb &#123; static int N = 10_0005, MOD = (int) 1e9 + 7; static int[] fact = new int[N], ifact = new int[N]; static &#123; fact[0] = 1; for (int i = 1; i &lt; N; ++i) &#123; fact[i] = (int) ((long) fact[i - 1] * i % MOD); &#125; ifact[N - 1] = inv(fact[N - 1]); for (int i = N - 2; i &gt;= 0; --i) &#123; ifact[i] = (int) ((long) ifact[i + 1] * (i + 1) % MOD); &#125; &#125; static int power(long a, long n) &#123; int res = 1; while (n &gt; 0) &#123; if ((n &amp; 1) == 1) &#123; res = (int) (a * res % MOD); &#125; a = a * a % MOD; n &gt;&gt;= 1; &#125; return res; &#125; static int inv(long x) &#123; return power(x, MOD - 2); &#125; static int c(int n, int r) &#123; return (int) ((long) fact[n] * ifact[r] % MOD * ifact[n - r] % MOD); &#125; &#125;","categories":["算法模板","数学"]},{"title":"算法模板/字符串","path":"/2024/06/02/算法/算法模板/字符串/","content":"字符串哈希class Hash &#123; static int P = 131, MOD = (int) 1e9 + 7; int n; int[] h, rh, p; Hash(char[] s) &#123; n = s.length; h = new int[n + 5]; rh = new int[n + 5]; p = new int[n + 5]; p[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; h[i] = (int) (((long) h[i - 1] * P % MOD + s[i - 1]) % MOD); rh[i] = (int) (((long) rh[i - 1] * P % MOD + s[n - i]) % MOD); p[i] = (int) ((long) p[i - 1] * P % MOD); &#125; &#125; int get(int l, int r) &#123; return get(h, l, r); &#125; int get(int[] h, int l, int r) &#123; return (h[r] - (int) ((long) h[l - 1] * p[r - l + 1] % MOD) + MOD) % MOD; &#125; boolean isPalindrome(int l, int r) &#123; return get(h, l, r) == get(rh, n - r + 1, n - l + 1); &#125; &#125; 最小表示法int minExp(char[] s) &#123; int n = s.length, i = 0, j = 1, k = 0; while (i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n) &#123; if (s[(i + k) % n] == s[(j + k) % n]) &#123; ++k; &#125; else &#123; if (s[(i + k) % n] &gt; s[(j + k) % n]) &#123; i = i + k + 1; &#125; else &#123; j = j + k + 1; &#125; if (i == j) &#123; ++i; &#125; k = 0; &#125; &#125; return Math.min(i, j); &#125;","categories":["算法模板","字符串"]},{"title":"算法模板/常用","path":"/2024/06/02/算法/算法模板/常用/","content":"容器class U &#123; static int[] toArray(List&lt;Integer&gt; list) &#123; return list.stream().mapToInt(Integer::intValue).toArray(); &#125; static int min(int[] arr) &#123; return Arrays.stream(arr).min().getAsInt(); &#125; static int max(int[] arr) &#123; return Arrays.stream(arr).max().getAsInt(); &#125; static &lt;T extends Comparable&lt;T&gt;&gt; T min(Collection&lt;T&gt; collection) &#123; return Collections.min(collection); &#125; static &lt;T extends Comparable&lt;T&gt;&gt; T max(Collection&lt;T&gt; collection) &#123; return Collections.max(collection); &#125; &#125; 二分class U &#123; static int bisect(int l, int r, Predicate&lt;Integer&gt; predicate, boolean inc) &#123; int res = -1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (predicate.test(mid)) &#123; res = mid; int _ = inc ? (l = mid + 1) : (r = mid - 1); &#125; else &#123; int _ = inc ? (r = mid - 1) : (l = mid + 1); &#125; &#125; return res; &#125; static long bisect(long l, long r, Predicate&lt;Long&gt; predicate, boolean inc) &#123; long res = -1; while (l &lt;= r) &#123; long mid = (l + r) &gt;&gt; 1; if (predicate.test(mid)) &#123; res = mid; long _ = inc ? (l = mid + 1) : (r = mid - 1); &#125; else &#123; long _ = inc ? (r = mid - 1) : (l = mid + 1); &#125; &#125; return res; &#125; static double bisect(double l, double r, Predicate&lt;Double&gt; predicate, boolean inc) &#123; double res = -1; while (l + 1e-8 &lt; r) &#123; double mid = (l + r) / 2; if (predicate.test(mid)) &#123; res = mid; double _ = inc ? (l = mid + 1) : (r = mid - 1); &#125; else &#123; double _ = inc ? (r = mid - 1) : (l = mid + 1); &#125; &#125; return res; &#125; &#125; 建图class G &#123; // 无权图 static List&lt;Integer&gt;[] graph(int n, int[][] edges) &#123; List&lt;Integer&gt;[] g = IntStream.range(0, n).boxed().map(_ -&gt; new ArrayList&lt;&gt;()).toArray(List[]::new); for (int[] edge : edges) &#123; int u = edge[0], v = edge[1]; g[u].add(v); g[v].add(u); &#125; return g; &#125; // 带权图 static List&lt;Pair&lt;Integer, Integer&gt;&gt;[] graph(int n, int[][] edges) &#123; List&lt;Pair&lt;Integer, Integer&gt;&gt;[] g = IntStream.range(0, n).boxed().map(_ -&gt; new ArrayList&lt;&gt;()).toArray(List[]::new); for (int[] edge : edges) &#123; int u = edge[0], v = edge[1], w = edge[2]; g[u].add(new Pair&lt;&gt;(v, w)); g[v].add(new Pair&lt;&gt;(u, w)); &#125; return g; &#125; // 树 static List&lt;Integer&gt;[] tree(int[] parent) &#123; int n = parent.length; List&lt;Integer&gt;[] g = IntStream.range(0, n).boxed().map(_ -&gt; new ArrayList&lt;&gt;()).toArray(List[]::new); for (int v = 0; v &lt; n; ++v) &#123; int u = parent[v]; if (u != -1) &#123; g[u].add(v); g[v].add(u); &#125; &#125; return g; &#125; &#125; 枚举子集class U &#123; // 升序 static List&lt;Integer&gt; subsets(int bitset, boolean inclusive) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int s = bitset; s &gt; 0; s = (s - 1) &amp; bitset) &#123; res.add(bitset ^ s); &#125; if (inclusive) &#123; res.add(bitset); &#125; return res; &#125; &#125; 全排列class U &#123; static void swap(int[] arr, int l, int r) &#123; int t = arr[l]; arr[l] = arr[r]; arr[r] = t; &#125; static void reverse(int[] arr, int l, int r) &#123; while (l &lt; r) &#123; swap(ar, l, r); ++l; --r; &#125; &#125; // [1, 2, 7, 4, 3, 1] -&gt; [1, 3, 1, 2, 4, 7] static boolean nextPermutation(int[] arr) &#123; int n = arr.length; int k = -1; for (int i = n - 2; i &gt;= 0; --i) &#123; if (arr[i] &lt; arr[i + 1]) &#123; k = i; break; &#125; &#125; if (k == -1) &#123; return false; &#125; for (int i = n - 1; i &gt; k; --i) &#123; if (arr[i] &gt; arr[k]) &#123; swap(arr, k, i); reverse(arr, k + 1, n - 1); break; &#125; &#125; return true; &#125; &#125; 合并区间class U &#123; List&lt;int[]&gt; merge(int[][] intervals) &#123; Arrays.sort(intervals, Comparator.comparingInt(interval -&gt; interval[0])); List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); for (int[] interval : intervals) &#123; int m = ans.size(); int l = interval[0], r = interval[1]; if (ans.isEmpty() || ans.get(m - 1)[1] &lt; l) &#123; ans.add(new int[] &#123; l, r &#125;); &#125; else &#123; ans.get(m - 1)[1] = Math.max(ans.get(m - 1)[1], r); &#125; &#125; return ans; &#125; &#125;","categories":["算法模板","常用"]},{"title":"算法模板/动态规划","path":"/2024/06/02/算法/算法模板/动态规划/","content":"数位dpclass U &#123; static long[][] f = new long[30][100]; static int[] digit = new int[30]; static long dfs(int i, boolean zero, boolean limit, int s) &#123; if (i == 0) &#123; return zero ? 0 : 1; &#125; if (!zero &amp;&amp; !limit &amp;&amp; f[i][s] &gt; -1) &#123; return f[i][s]; &#125; long res = 0; int up = limit ? digit[i] : 9; for (int d = 0; d &lt;= up; ++d) &#123; res += dfs(i - 1, zero &amp;&amp; d == 0, limit &amp;&amp; d == up, s); &#125; if (!zero &amp;&amp; !limit) &#123; f[i][s] = res; &#125; return res; &#125; static long run(long x) &#123; int len = 0; while (x &gt; 0) &#123; digit[++len] = (int) (x % 10); x /= 10; &#125; for (long[] f_i : f) &#123; Arrays.fill(f_i, -1); &#125; return dfs(len, true, true, 0); &#125; &#125; 区间不满足前缀和性质时。 class U &#123; static long[][] f = new long[30][100]; static int[] downdigit = new int[30], updigit = new int[30]; static long dfs(int i, boolean zero, boolean downlimit, boolean uplimit, int s) &#123; if (i == 0) &#123; return zero ? 0 : 1; &#125; if (!zero &amp;&amp; !downlimit &amp;&amp; !uplimit &amp;&amp; f[i][s] &gt; -1) &#123; return f[i][s]; &#125; long res = 0; int down = downlimit ? downdigit[i] : 0, up = uplimit ? updigit[i] : 9; for (int d = down; d &lt;= up; ++d) &#123; res += dfs(i - 1, zero &amp;&amp; d == 0, downlimit &amp;&amp; d == down, uplimit &amp;&amp; d == up, s); &#125; if (!zero &amp;&amp; !downlimit &amp;&amp; !uplimit) &#123; f[i][s] = res; &#125; return res; &#125; static long run(int l, int r) &#123; toArray(downdigit, l); toArray(updigit, r); for (long[] f_i : f) &#123; Arrays.fill(f_i, -1); &#125; return dfs(downdigit.length - 1, true, true, true, 0); &#125; static void toArray(int[] digit, long x) &#123; int len = 0; while (x &gt; 0) &#123; digit[++len] = (int) (x % 10); x /= 10; &#125; &#125; &#125;","categories":["算法模板","动态规划"]},{"title":"Vite使用svg","path":"/2024/06/02/开发/Vue/Vite使用svg/","content":"安装npm i vite-plugin-svg-icons 使用vite.config.js import &#123; defineConfig &#125; from &quot;vite&quot;; import vue from &quot;@vitejs/plugin-vue&quot;; import path from &quot;path&quot;; import &#123; createSvgIconsPlugin &#125; from &quot;vite-plugin-svg-icons&quot;; // https://vitejs.dev/config/ export default defineConfig(&#123; plugins: [ vue(), createSvgIconsPlugin(&#123; symbolId: &quot;icon-[name]&quot;, iconDirs: [path.resolve(&quot;./src/assets/icons/svg&quot;)] &#125;) ] &#125;); main.js import App from &quot;./App.vue&quot;; import SvgIcon from &quot;./components/svg-icon/SvgIcon.vue&quot;; import &#123; createApp &#125; from &quot;vue&quot;; import &quot;virtual:svg-icons-register&quot;; createApp(App).component(&quot;svg-icon&quot;, SvgIcon).mount(&quot;#app&quot;); SvgIcon.vue&lt;script setup&gt; defineProps(&#123; name: String &#125;); &lt;/script&gt; &lt;template&gt; &lt;svg class=&quot;svg-icon&quot; :name=&quot;name&quot;&gt; &lt;use :xlink:href=&quot;`#icon-$&#123;name&#125;`&quot; /&gt; &lt;/svg&gt; &lt;/template&gt; &lt;style lang=&quot;less&quot; scoped&gt; .svg-icon &#123; width: 1em; height: 1em; fill: currentColor; &#125; &lt;/style&gt;"},{"title":"LeetCode第399场周赛","path":"/2024/06/02/算法/LeetCode/周赛/LeetCode第399场周赛/","content":"https://leetcode.cn/contest/weekly-contest-399 3. 优质数对的总数 II$nums2_j$为$\\frac{nums1_i}{k}$的因子。 class Solution &#123; void divide(Map&lt;Integer, Integer&gt; counter, int x) &#123; for (int i = 1; i * i &lt;= x; ++i) &#123; if (x % i == 0) &#123; counter.merge(i, 1, Integer::sum); if (i * i &lt; x) &#123; counter.merge(x / i, 1, Integer::sum); &#125; &#125; &#125; &#125; public long numberOfPairs(int[] nums1, int[] nums2, int k) &#123; Map&lt;Integer, Integer&gt; counter = new HashMap&lt;&gt;(); for (int x : nums1) &#123; if (x % k == 0) &#123; divide(counter, x / k); &#125; &#125; long ans = 0; for (int x : nums2) &#123; ans += counter.getOrDefault(x, 0); &#125; return ans; &#125; &#125; 4. 不包含相邻元素的子序列的最大和class XNode &#123; int l, mid, r, len; // a[0]: 0 0 // a[1]: 0 ? // a[2]: ? 0 // a[3]: ? ? int[] a = new int[4]; XNode left, right; XNode(int l, int r) &#123; this.l = l; this.r = r; mid = (l + r) &gt;&gt; 1; len = r - l + 1; &#125; void merge() &#123; // 0 0 ? 0, 0 ? 0 0 a[0] = Math.max(left.a[0] + right.a[2], left.a[1] + right.a[0]); // 0 0 ? ?, 0 ? 0 ? a[1] = Math.max(left.a[0] + right.a[3], left.a[1] + right.a[1]); // ? 0 ? 0, ? ? 0 0 a[2] = Math.max(left.a[2] + right.a[2], left.a[3] + right.a[0]); // ? 0 ? ?, ? ? 0 ? a[3] = Math.max(left.a[2] + right.a[3], left.a[3] + right.a[1]); &#125; &#125; class XTree &#123; XNode root; XTree(int[] arr) &#123; int n = arr.length; root = build(arr, 0, n - 1); &#125; XNode build(int[] arr, int l, int r) &#123; XNode node = new XNode(l, r); if (l == r) &#123; node.a[3] = Math.max(arr[l], 0); return node; &#125; node.left = build(arr, l, node.mid); node.right = build(arr, node.mid + 1, r); node.merge(); return node; &#125; void modify(int i, int x) &#123; modify(i, x, root); &#125; void modify(int i, int x, XNode node) &#123; if (node.l == node.r) &#123; node.a[3] = Math.max(x, 0); return; &#125; if (i &lt;= node.mid) &#123; modify(i, x, node.left); &#125; else &#123; modify(i, x, node.right); &#125; node.merge(); &#125; &#125; class Solution &#123; static int MOD = (int) 1e9 + 7; public int maximumSumSubsequence(int[] nums, int[][] queries) &#123; XTree tree = new XTree(nums); int ans = 0; for (int[] query : queries) &#123; int pos = query[0], x = query[1]; tree.modify(pos, x); ans = (ans + tree.root.a[3]) % MOD; &#125; return ans; &#125; &#125;","tags":["线段树","数学"],"categories":["LeetCode","周赛"]},{"title":"LeetCode第395场周赛","path":"/2024/06/02/算法/LeetCode/周赛/LeetCode第395场周赛/","content":"https://leetcode.cn/contest/weekly-contest-395 1. 找出与数组相加的整数 Iclass Solution &#123; public int addedInteger(int[] nums1, int[] nums2) &#123; Arrays.sort(nums1); Arrays.sort(nums2); return nums2[0] - nums1[0]; &#125; &#125; 2. 找出与数组相加的整数 II删除两个元素等价于$(0, 1, 2)$三个下标会剩下一个，反向枚举保留的下标$k$保证答案从小到大。 class Solution &#123; public int minimumAddedInteger(int[] nums1, int[] nums2) &#123; Arrays.sort(nums1); Arrays.sort(nums2); int n = nums1.length, m = nums2.length; for (int k = 2; k &gt;= 0; --k) &#123; int x = nums2[0] - nums1[k]; for (int i = k, j = 0; i &lt; n; ++i) &#123; if (j &lt; m &amp;&amp; nums1[i] + x == nums2[j]) &#123; ++j; if (j == m) &#123; return x; &#125; &#125; &#125; &#125; return -1; &#125; &#125; 3. 数组最后一个元素的最小值二进制下把$n - 1$的每一位填到$x$的$0$中。 class Solution &#123; public long minEnd(int n, int x) &#123; --n; long ans = x; int i = 0; while (n &gt; 0) &#123; // i &gt;= 32 if ((ans &gt;&gt; i &amp; 1) == 0) &#123; ans |= (n &amp; 1L) &lt;&lt; i; n &gt;&gt;= 1; &#125; ++i; &#125; return ans; &#125; &#125; 4. 找出唯一性数组的中位数长度为$n$的数组共有$m &#x3D; \\frac{(1 + n)n}{2}$个子数组，中位数为第$k &#x3D; \\lceil \\frac{m}{2} \\rceil$个。 设$f(x)$表示$\\sum_{l &#x3D; 0}^{n - 1} \\sum_{r &#x3D; l}^{n - 1} distinct(nums_{l \\dots r}) \\leq x$，问题转换为求最小的$x$满足$f(x) \\geq k$，$f(x)$具有单调性可以二分。 class Solution &#123; static int bisect(int l, int r, Predicate&lt;Integer&gt; predicate, boolean inc) &#123; int res = -1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (predicate.test(mid)) &#123; res = mid; int _ = inc ? (l = mid + 1) : (r = mid - 1); &#125; else &#123; int _ = inc ? (r = mid - 1) : (l = mid + 1); &#125; &#125; return res; &#125; public int medianOfUniquenessArray(int[] nums) &#123; int n = nums.length; long m = (1L + n) * n / 2, k = (m + 1) / 2; return bisect(1, n, _x -&gt; &#123; Map&lt;Integer, Integer&gt; counter = new HashMap&lt;&gt;(); long fx = 0; for (int l = 0, r = 0; r &lt; n; ++r) &#123; counter.merge(nums[r], 1, Integer::sum); while (counter.size() &gt; _x) &#123; int x = nums[l]; if (counter.merge(x, -1, Integer::sum) == 0) &#123; counter.remove(x); &#125; ++l; &#125; fx += r - l + 1; if (fx &gt;= k) &#123; return true; &#125; &#125; return false; &#125;, false); &#125; &#125;","tags":["模拟","二分","双指针"],"categories":["LeetCode","周赛"]},{"title":"LeetCode第398场周赛","path":"/2024/06/02/算法/LeetCode/周赛/LeetCode第398场周赛/","content":"https://leetcode.cn/contest/weekly-contest-398 1. 特殊数组 Iclass Solution &#123; public boolean isArraySpecial(int[] nums) &#123; int n = nums.length; for (int i = 1; i &lt; n; ++i) &#123; int x = nums[i - 1] + nums[i]; if ((x &amp; 1) == 0) &#123; return false; &#125; &#125; return true; &#125; &#125; 2. 特殊数组 IIclass Solution &#123; public boolean[] isArraySpecial(int[] nums, int[][] queries) &#123; int n = nums.length, m = queries.length; int[] s = new int[n]; for (int i = 1; i &lt; n; ++i) &#123; int x = nums[i - 1] + nums[i]; s[i] = s[i - 1] + (x &amp; 1 ^ 1); &#125; boolean[] ans = new boolean[m]; for (int i = 0; i &lt; m; ++i) &#123; int l = queries[i][0], r = queries[i][1]; ans[i] = s[r] - s[l] == 0; &#125; return ans; &#125; &#125; 3. 所有数对中数位不同之和class Solution &#123; public long sumDigitDifferences(int[] nums) &#123; long ans = 0; for (int __ = 0, k = 1; __ &lt;= 10; ++__, k *= 10) &#123; int[] cnt = new int[10]; for (int x : nums) &#123; ++cnt[x / k % 10]; &#125; for (int i = 0; i &lt; 9; ++i) &#123; for (int j = i + 1; j &lt;= 9; ++j) &#123; ans += (long) cnt[i] * cnt[j]; &#125; &#125; &#125; return ans; &#125; &#125; 4. 到达第 K 级台阶的方案数设操作二次数为$j$，操作一次数为$i &#x3D; 2^j - k$。 操作一不能连续等价于在$j$个操作数二前后插入$i$个操作一，方案数为$C_{j + 1}^{i}$。 答案为： $$\\sum_{j &#x3D; 0}^{29} C_{j + 1}^{i}$$ class Comb &#123; static int N = 5005; static long[][] f = new long[N][N]; static &#123; for (int i = 1; i &lt; N; ++i) &#123; f[i][0] = f[i][i] = 1; for (int j = 1; j &lt; i; ++j) &#123; f[i][j] = f[i - 1][j - 1] + f[i - 1][j]; &#125; &#125; &#125; static long c(int n, int r) &#123; return f[n][r]; &#125; &#125; class Solution &#123; static int B = 30; public int waysToReachStair(int k) &#123; int ans = 0; for (int j = 0; j &lt; B; ++j) &#123; int i = (1 &lt;&lt; j) - k; if (0 &lt;= i &amp;&amp; i &lt;= j + 1) &#123; ans += (int) Comb.c(j + 1, i); &#125; &#125; return ans; &#125; &#125;","tags":["组合数"],"categories":["LeetCode","周赛"]},{"title":"LeetCode第128场双周赛","path":"/2024/06/02/算法/LeetCode/双周赛/LeetCode第128场双周赛/","content":"https://leetcode.cn/contest/biweekly-contest-128 1. 字符串的分数class Solution &#123; public int scoreOfString(String s) &#123; int n = s.length(); int ans = 0; for (int i = 1; i &lt; n; ++i) &#123; ans += Math.abs(s.charAt(i) - s.charAt(i - 1)); &#125; return ans; &#125; &#125; 2. 覆盖所有点的最少矩形数目class Solution &#123; public int minRectanglesToCoverPoints(int[][] points, int w) &#123; Arrays.sort(points, Comparator.comparingInt(point -&gt; point[0])); int n = points.length; int r = points[0][0] + w, ans = 1; for (int i = 1; i &lt; n; ++i) &#123; if (r &lt; points[i][0]) &#123; r = points[i][0] + w; ++ans; &#125; &#125; return ans; &#125; &#125; 3. 访问消失节点的最少时间class Solution &#123; static List&lt;Pair&lt;Integer, Integer&gt;&gt;[] graph(int n, int[][] edges) &#123; List&lt;Pair&lt;Integer, Integer&gt;&gt;[] g = IntStream.range(0, n).boxed().map(_ -&gt; new ArrayList&lt;&gt;()).toArray(List[]::new); for (int[] edge : edges) &#123; int u = edge[0], v = edge[1], w = edge[2]; g[u].add(new Pair&lt;&gt;(v, w)); g[v].add(new Pair&lt;&gt;(u, w)); &#125; return g; &#125; static long INF = Long.MAX_VALUE &gt;&gt; 1; static long[] run(List&lt;Pair&lt;Integer, Integer&gt;&gt;[] g, int[] disappear, int s) &#123; Queue&lt;Pair&lt;Integer, Long&gt;&gt; q = new PriorityQueue&lt;&gt;(Comparator.comparingLong(Pair::getValue)); boolean[] vis = new boolean[g.length]; long[] dist = LongStream.range(0, g.length).map(_ -&gt; INF).toArray(); q.offer(new Pair&lt;&gt;(s, dist[s] = 0)); while (!q.isEmpty()) &#123; int u = q.poll().getKey(); if (vis[u]) &#123; continue; &#125; vis[u] = true; for (Pair&lt;Integer, Integer&gt; edge : g[u]) &#123; int v = edge.getKey(), w = edge.getValue(); long d = dist[u] + w; if (d &lt; disappear[v] &amp;&amp; d &lt; dist[v]) &#123; q.offer(new Pair&lt;&gt;(v, dist[v] = d)); &#125; &#125; &#125; return Arrays.stream(dist).map(dist_i -&gt; dist_i == INF ? -1 : dist_i).toArray(); &#125; public int[] minimumTime(int n, int[][] edges, int[] disappear) &#123; return Arrays.stream(run(graph(n, edges), disappear, 0)).mapToInt(Math::toIntExact).toArray(); &#125; &#125; 4. 边界元素是最大值的子数组数目 单调栈 维护一个单调递减栈以及栈中元素出现次数$count$。 遍历$nums$，当$nums_i$等于栈顶元素时可以组成$count_{nums_i}$个满足要求的子数组，累加即为答案。 class Solution &#123; public long numberOfSubarrays(int[] nums) &#123; ArrayDeque&lt;int[]&gt; s = new ArrayDeque&lt;&gt;(List.of(new int[] &#123; Integer.MAX_VALUE, 0 &#125;)); long ans = nums.length; for (int x : nums) &#123; while (x &gt; s.peek()[0]) &#123; s.pop(); &#125; if (x == s.peek()[0]) &#123; ans += s.peek()[1]++; &#125; else &#123; // x &lt; s.peek()[0] s.push(new int[] &#123; x, 1 &#125;); &#125; &#125; return ans; &#125; &#125; 动态开点线段树 线段树支持以下操作： 单点修改 单点查询 区间清零 遍历$nums$，$nums_i$权值$+ 1$， $\\lt nums_i$的权值全部修改$0$，累加权值即为答案。 class EXNode &#123; int l, mid, r, len; int cnt; boolean zero; EXNode left, right; EXNode(int l, int r) &#123; this.l = l; this.r = r; mid = (l + r) &gt;&gt; 1; len = r - l + 1; &#125; void spread() &#123; if (left == null) &#123; left = new EXNode(l, mid); &#125; if (right == null) &#123; right = new EXNode(mid + 1, r); &#125; if (zero) &#123; left.zero(); right.zero(); zero = false; &#125; &#125; void zero() &#123; zero = true; cnt = 0; &#125; &#125; class EXTree &#123; EXNode root = new EXNode(1, (int) 1e9); int add(int i) &#123; return add(i, root); &#125; int add(int i, EXNode node) &#123; if (node.l == node.r) &#123; return ++node.cnt; &#125; node.spread(); if (i &lt;= node.mid) &#123; return add(i, node.left); &#125; else &#123; return add(i, node.right); &#125; &#125; void zero(int l, int r) &#123; zero(l, r, root); &#125; void zero(int l, int r, EXNode node) &#123; if (l &lt;= node.l &amp;&amp; node.r &lt;= r) &#123; node.zero(); return; &#125; node.spread(); if (l &lt;= node.mid) &#123; zero(l, r, node.left); &#125; if (node.mid + 1 &lt;= r) &#123; zero(l, r, node.right); &#125; &#125; &#125; class Solution &#123; public long numberOfSubarrays(int[] nums) &#123; EXTree Tree = new EXTree(); long ans = 0; for (int x : nums) &#123; if (x &gt; 1) &#123; Tree.zero(1, x - 1); &#125; ans += Tree.add(x); &#125; return ans; &#125; &#125;","tags":["单调栈","线段树"],"categories":["LeetCode","双周赛"]},{"title":"LeetCode第129场双周赛","path":"/2024/06/02/算法/LeetCode/双周赛/LeetCode第129场双周赛/","content":"https://leetcode.cn/contest/biweekly-contest-129 1. 构造相同颜色的正方形class Solution &#123; boolean valid(char[][] grid, int x, int y) &#123; int[] cnt = new int[2]; ++cnt[grid[x][y] &amp; 1]; ++cnt[grid[x + 1][y] &amp; 1]; ++cnt[grid[x][y + 1] &amp; 1]; ++cnt[grid[x + 1][y + 1] &amp; 1]; return Math.max(cnt[0], cnt[1]) &gt;= 3; &#125; public boolean canMakeSquare(char[][] grid) &#123; return valid(grid, 0, 0) || valid(grid, 1, 0) || valid(grid, 0, 1) || valid(grid, 1, 1); &#125; &#125; 2. 直角三角形class Solution &#123; int get(int[][] s, int x1, int y1, int x2, int y2) &#123; return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]; &#125; public long numberOfRightTriangles(int[][] grid) &#123; int n = grid.length, m = grid[0].length; int[][] s = new int[n + 5][m + 5]; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + grid[i - 1][j - 1]; &#125; &#125; long ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (grid[i - 1][j - 1] == 1) &#123; int x = get(s, i, 1, i, m) - 1, y = get(s, 1, j, n, j) - 1; ans += (long) x * y; &#125; &#125; &#125; return ans; &#125; &#125; 3. 找出所有稳定的二进制数组 I &amp; 4. 找出所有稳定的二进制数组 II设$f_{i, j, k}$表示$i$个$0$，$j$个$1$，末尾为$k$的方案数。 相同数字至多连续出现$limit$次，第$i + j - limit$位为$k \\oplus 1$。 对于$f_{i, j, 0}$，$f_{i - 1, j, 0}$包括了末尾连续出现$limit$个$0$的方案数，加上当前位则连续出现了$limit + 1$个$0$，为非法状态，此时需要减去该方案数即$f_{i - 1 - limit, j, 1}$。 递推公式为： $$f_{i, j, k} &#x3D;\\begin{cases}f_{i - 1, j, 0} + f_{i - 1, j, 1} - f_{i - 1 - limit, j, 1} &amp; \\text{if $k$ &#x3D; 0} \\\\f_{i, j - 1, 0} + f_{i, j - 1, 1} - f_{i, j - 1 - limit, 0} &amp; \\text{if $k$ &#x3D; 1}\\end{cases}$$ class Solution &#123; static int MOD = (int) 1e9 + 7; public int numberOfStableArrays(int zero, int one, int limit) &#123; int[][][] f = new int[zero + 5][one + 5][2]; for (int i = 1; i &lt;= Math.min(zero, limit); ++i) &#123; f[i][0][0] = 1; &#125; for (int j = 1; j &lt;= Math.min(one, limit); ++j) &#123; f[0][j][1] = 1; &#125; for (int i = 1; i &lt;= zero; ++i) &#123; for (int j = 1; j &lt;= one; ++j) &#123; f[i][j][0] = (f[i - 1][j][0] + f[i - 1][j][1]) % MOD; f[i][j][1] = (f[i][j - 1][0] + f[i][j - 1][1]) % MOD; if (i - 1 - limit &gt;= 0) &#123; f[i][j][0] = (f[i][j][0] - f[i - 1 - limit][j][1] + MOD) % MOD; &#125; if (j - 1 - limit &gt;= 0) &#123; f[i][j][1] = (f[i][j][1] - f[i][j - 1 - limit][0] + MOD) % MOD; &#125; &#125; &#125; return (f[zero][one][0] + f[zero][one][1]) % MOD; &#125; &#125;","tags":["前缀和","动态规划"],"categories":["LeetCode","双周赛"]},{"title":"LeetCode第131场双周赛","path":"/2024/06/02/算法/LeetCode/双周赛/LeetCode第131场双周赛/","content":"https://leetcode.cn/contest/biweekly-contest-131 1. 求出出现两次数字的 XOR 值class Solution &#123; public int duplicateNumbersXOR(int[] nums) &#123; long s = 0; int ans = 0; for (int x : nums) &#123; if ((s &gt;&gt; x &amp; 1) == 1) &#123; ans ^= x; &#125; else &#123; s |= 1L &lt;&lt; x; &#125; &#125; return ans; &#125; &#125; 2. 查询数组中元素的出现位置class Solution &#123; public int[] occurrencesOfElement(int[] nums, int[] queries, int x) &#123; int n = nums.length; List&lt;Integer&gt; indices = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; ++i) &#123; if (nums[i] == x) &#123; indices.add(i); &#125; &#125; return Arrays.stream(queries).map(i -&gt; i - 1 &lt; indices.size() ? indices.get(i - 1) : -1).toArray(); &#125; &#125; 3. 所有球里面不同颜色的数目class Solution &#123; public int[] queryResults(int limit, int[][] queries) &#123; Map&lt;Integer, Integer&gt; color = new HashMap&lt;&gt;(), counter = new HashMap&lt;&gt;(); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for (int[] query : queries) &#123; int x = query[0], y = query[1]; if (color.containsKey(x)) &#123; int c = color.get(x); if (counter.merge(c, -1, Integer::sum) == 0) &#123; counter.remove(c); &#125; &#125; color.put(x, y); counter.merge(y, 1, Integer::sum); ans.add(counter.size()); &#125; return ans.stream().mapToInt(Integer::intValue).toArray(); &#125; &#125; 4. 物块放置查询class XNode &#123; int l, mid, r, len; int leftVal, rightVal, maxVal; XNode left, right; XNode(int l, int r) &#123; this.l = l; this.r = r; mid = (l + r) &gt;&gt; 1; len = r - l + 1; &#125; XNode(XNode left, XNode right) &#123; this(left.l, right.r); this.left = left; this.right = right; &#125; void merge() &#123; maxVal = Collections.max(List.of(left.maxVal, right.maxVal, left.rightVal + right.leftVal)); leftVal = left.leftVal + (left.leftVal == left.len ? right.leftVal : 0); rightVal = right.rightVal + (right.rightVal == right.len ? left.rightVal : 0); &#125; &#125; class XTree &#123; XNode root; XTree(int n) &#123; root = build(0, n); &#125; XNode build(int l, int r) &#123; XNode node = new XNode(l, r); if (l == r) &#123; node.leftVal = node.rightVal = node.maxVal = 1; return node; &#125; node.left = build(l, node.mid); node.right = build(node.mid + 1, r); node.merge(); return node; &#125; void add(int i) &#123; add(i, root); &#125; void add(int i, XNode node) &#123; if (node.l == node.r) &#123; node.leftVal = node.rightVal = node.maxVal = 0; return; &#125; if (i &lt;= node.mid) &#123; add(i, node.left); &#125; else &#123; add(i, node.right); &#125; node.merge(); &#125; XNode query(int l, int r) &#123; return query(l, r, root); &#125; XNode query(int l, int r, XNode node) &#123; if (l &lt;= node.l &amp;&amp; node.r &lt;= r) &#123; return node; &#125; if (r &lt;= node.mid) &#123; return query(l, r, node.left); &#125; if (node.mid + 1 &lt;= l) &#123; return query(l, r, node.right); &#125; XNode left = query(l, r, node.left); XNode right = query(l, r, node.right); XNode res = new XNode(left, right); res.merge(); return res; &#125; &#125; class Solution &#123; int query(XTree tree, int l, int r) &#123; if (l == r) &#123; return 0; &#125; if (l + 1 == r) &#123; return 1; &#125; XNode node = tree.query(l, r, tree.root); // 没有障碍物 if (node.maxVal == node.len) &#123; return node.maxVal - 1; &#125; // 两个及以上障碍物 if (node.maxVal == tree.query(l + 1, r - 1).maxVal) &#123; return node.maxVal + 1; &#125; // 一个障碍物 return node.maxVal; &#125; public List&lt;Boolean&gt; getResults(int[][] queries) &#123; int r = Arrays.stream(queries).max(Comparator.comparingInt(query -&gt; query[1])).get()[1]; XTree tree = new XTree(r); List&lt;Boolean&gt; ans = new ArrayList&lt;&gt;(); for (int[] query : queries) &#123; int type = query[0], x = query[1]; if (type == 1) &#123; tree.add(x); &#125; else &#123; int size = query[2]; ans.add(query(tree, 0, x) &gt;= size); &#125; &#125; return ans; &#125; &#125;","tags":["线段树"],"categories":["LeetCode","双周赛"]},{"title":"Hexo","path":"/2024/06/02/软件/Hexo/Hexo/","content":"运行环境Node.jshttps://nodejs.org/en npm i -g cnpm --registry=https://registry.npmmirror.com # 其他命令 node -v cnpm -v cnpm config get registry cnpm config set registry https://registry.npmmirror.com 使用PowerShell执行命令时可能遇到因为在此系统上禁止运行脚本，以管理员身份运行PowerShell执行以下命令。 set-executionpolicy remotesigned y Githttps://git-scm.com/download/win 64-bit Git for Windows Setup. git config --global user.name &lt;name&gt; git config --global user.email &lt;email&gt; # 其他命令 git -v git config --list 安装 &amp; 运行cnpm i -g hexo-cli hexo init hexo s # 其他命令 hexo -v 安装主题以Stellar为例。 cd themes git clone https://github.com/xaoxuu/hexo-theme-stellar Stellar _config.yml theme: Stellar 部署npm i hexo-deployer-git hexo clean hexo d 配置_config.yml title: Stler&#39;s Blog author: Stler avatar: https://ts1.cn.mm.bing.net/th/id/R-C.4e6232794f523ca4ae68a487db22ec7a?rik=3IigK%2bYxioLWzA&amp;riu=http%3a%2f%2fpic.52112.com%2fJPG-180514%2f180514_153%2fsC3BsPCXLt_small.jpg&amp;ehk=pQKfO1Ioo0cLwwlTNpiytZJJJhEfBwa38%2bSkq%2bDxPzc%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0 language: zh-CN timezone: Asia/Shanghai syntax_highlighter: marked: langPrefix: language- index_generator: per_page: 0 deploy: type: git repo: https://github.com/Stler4j/Stler4j.github.io.git branch: main","categories":["Hexo"]},{"title":"Hexo/Stellar","path":"/2024/06/02/软件/Hexo/Stellar/","content":"配置_config.Stellar.yml article: auto_excerpt: 0 plugins: mathjax: enable: true inject: head: &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-web/style.css&quot; /&gt; style: font-family: logo: &#39;&quot;LXGW WenKai Screen&quot;, system-ui, &quot;Microsoft Yahei&quot;, &quot;Segoe UI&quot;, -apple-system, Roboto, Ubuntu, &quot;Helvetica Neue&quot;, Arial, &quot;WenQuanYi Micro Hei&quot;, sans-serif&#39; body: &#39;&quot;LXGW WenKai Screen&quot;, system-ui, &quot;Microsoft Yahei&quot;, &quot;Segoe UI&quot;, -apple-system, Roboto, Ubuntu, &quot;Helvetica Neue&quot;, Arial, &quot;WenQuanYi Micro Hei&quot;, sans-serif&#39; animated_avatar: background: &#39;&#39; leftbar: background: var(--leftbar-bg) background-image: &#39;&#39; blur-px: 0 color: theme: &#39;hsl(230, 100%, 69%)&#39; link: &#39;hsl(230, 100%, 69%)&#39; 图标themes/Stellar/_data/icons.yml default:leftbar: &lt;svg t=&quot;1715527288117&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;87714&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M950.24 676.672L512 919.2 73.76 676.672 512 434.144z&quot; fill=&quot;#F8F3F3&quot; p-id=&quot;87715&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M512 927.2a7.952 7.952 0 0 1-3.872-1.008L69.872 683.664a8.016 8.016 0 0 1 0-14.016l438.256-242.528a7.936 7.936 0 0 1 7.744 0l438.256 242.528a8.016 8.016 0 0 1 0 14.016L515.872 926.208a7.92 7.92 0 0 1-3.872 0.992zM90.272 676.672L512 910.064l421.728-233.392L512 443.28 90.272 676.672z&quot; fill=&quot;#63312D&quot; p-id=&quot;87716&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M512 919.2L73.76 676.672v55.072L512 974.272l438.24-242.528v-55.072z&quot; fill=&quot;#E1DDDD&quot; p-id=&quot;87717&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M512 982.272a7.952 7.952 0 0 1-3.872-1.008L69.872 738.736a8.016 8.016 0 0 1-4.128-7.008v-55.056a8.032 8.032 0 0 1 11.872-7.008L512 910.064l434.368-240.384a8.016 8.016 0 0 1 11.872 7.008v55.056c0 2.912-1.584 5.6-4.128 7.008l-438.24 242.512a7.952 7.952 0 0 1-3.872 1.008zM81.744 727.008L512 965.12l430.256-238.112V690.24L515.872 926.208a7.936 7.936 0 0 1-7.744 0L81.744 690.256v36.752z&quot; fill=&quot;#63312D&quot; p-id=&quot;87718&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M950.24 484.464L512 726.992 73.76 484.464 512 241.936z&quot; fill=&quot;#84DBFF&quot; p-id=&quot;87719&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M134.16 484.464l408.032-225.808L512 241.936 73.76 484.464 512 726.992l30.192-16.72z&quot; fill=&quot;#CAF4FF&quot; p-id=&quot;87720&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M512 734.992a7.952 7.952 0 0 1-3.872-1.008L69.872 491.472a8.016 8.016 0 0 1 0-14.016l438.256-242.528a7.936 7.936 0 0 1 7.744 0l438.256 242.528a8.016 8.016 0 0 1 0 14.016L515.872 733.984a7.952 7.952 0 0 1-3.872 1.008zM90.272 484.464L512 717.84l421.728-233.376L512 251.072 90.272 484.464z&quot; fill=&quot;#63312D&quot; p-id=&quot;87721&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M512 726.992L73.76 484.464v55.072L512 782.064l438.24-242.528v-55.072z&quot; fill=&quot;#52BADB&quot; p-id=&quot;87722&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M512 790.064a7.952 7.952 0 0 1-3.872-1.008L69.872 546.528a8.016 8.016 0 0 1-4.128-7.008v-55.056a8.032 8.032 0 0 1 11.872-7.008L512 717.84l434.368-240.368a8.016 8.016 0 0 1 11.872 7.008v55.056c0 2.912-1.584 5.6-4.128 7.008l-438.24 242.512a7.952 7.952 0 0 1-3.872 1.008zM81.744 534.816L512 772.928l430.256-238.112v-36.784L515.872 733.984a7.936 7.936 0 0 1-7.744 0L81.744 498.032v36.784z&quot; fill=&quot;#63312D&quot; p-id=&quot;87723&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M950.24 292.256L512 534.784 73.76 292.256 512 49.728z&quot; fill=&quot;#F9DD9D&quot; p-id=&quot;87724&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M141.904 292.256L546.08 68.592 512 49.728 73.76 292.256 512 534.784l34.08-18.848z&quot; fill=&quot;#FFEECF&quot; p-id=&quot;87725&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M512 542.784a7.952 7.952 0 0 1-3.872-1.008L69.872 299.264a8.016 8.016 0 0 1 0-14.016L508.128 42.736a7.936 7.936 0 0 1 7.744 0l438.256 242.528a8.016 8.016 0 0 1 0 14.016L515.872 541.776a7.952 7.952 0 0 1-3.872 1.008zM90.272 292.272L512 525.648l421.728-233.376L512 58.88 90.272 292.272z&quot; fill=&quot;#63312D&quot; p-id=&quot;87726&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M512 534.784L73.76 292.256v55.072L512 589.856l438.24-242.528v-55.072z&quot; fill=&quot;#EFC36A&quot; p-id=&quot;87727&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M512 597.856a7.952 7.952 0 0 1-3.872-1.008L69.872 354.336a8.016 8.016 0 0 1-4.128-7.008v-55.056a8.032 8.032 0 0 1 11.872-7.008L512 525.648 946.368 285.28a8.016 8.016 0 0 1 11.872 7.008v55.056c0 2.912-1.584 5.6-4.128 7.008l-438.24 242.512a7.92 7.92 0 0 1-3.872 0.992zM81.744 342.608L512 580.72l430.256-238.112v-36.784L515.872 541.776a7.936 7.936 0 0 1-7.744 0L81.744 305.824v36.784z&quot; fill=&quot;#63312D&quot; p-id=&quot;87728&quot;&gt;&lt;/path&gt;&lt;/svg&gt; default:rightbar: &lt;svg t=&quot;1715527921227&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;132681&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M91.89 238.457c-29.899 0-54.133 24.239-54.133 54.134 0 29.899 24.234 54.137 54.133 54.137s54.138-24.238 54.138-54.137c0-29.896-24.239-54.134-54.138-54.134z&quot; fill=&quot;#E5594F&quot; p-id=&quot;132682&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M91.89 462.463c-29.899 0-54.133 24.239-54.133 54.139 0 29.895 24.234 54.133 54.133 54.133s54.138-24.238 54.138-54.133c0-29.9-24.239-54.139-54.138-54.139z&quot; fill=&quot;#C45FA0&quot; p-id=&quot;132683&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M91.89 686.475c-29.899 0-54.133 24.237-54.133 54.133 0 29.899 24.234 54.138 54.133 54.138s54.138-24.238 54.138-54.138c0-29.896-24.239-54.133-54.138-54.133z&quot; fill=&quot;#F39A2B&quot; p-id=&quot;132684&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M941.26 234.723H328.964c-28.867 0-52.263 23.4-52.263 52.268v3.734c0 28.868 23.396 52.269 52.263 52.269H941.26c28.869 0 52.269-23.401 52.269-52.269v-3.734c-0.001-28.868-23.4-52.268-52.269-52.268z&quot; fill=&quot;#F0D043&quot; p-id=&quot;132685&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M941.26 682.74H328.964c-28.867 0-52.263 23.399-52.263 52.268v3.734c0 28.863 23.396 52.269 52.263 52.269H941.26c28.869 0 52.269-23.405 52.269-52.269v-3.734c-0.001-28.868-23.4-52.268-52.269-52.268z&quot; fill=&quot;#4A5699&quot; p-id=&quot;132686&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M709.781 458.729H328.964c-28.867 0-52.263 23.4-52.263 52.269v3.734c0 28.873 23.396 52.269 52.263 52.269h380.817c28.866 0 52.271-23.396 52.271-52.269v-3.734c0.001-28.869-23.405-52.269-52.271-52.269z&quot; fill=&quot;#E5594F&quot; p-id=&quot;132687&quot;&gt;&lt;/path&gt;&lt;/svg&gt; default:calendar: &lt;svg t=&quot;1715526145742&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;14632&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M879.28 916.37H145.9c-9.86 0-17.86-7.99-17.86-17.86V234.64c0-9.86 7.99-17.86 17.86-17.86h733.38c9.86 0 17.86 7.99 17.86 17.86v663.88c0 9.86-7.99 17.85-17.86 17.85z&quot; fill=&quot;#FFFFFF&quot; p-id=&quot;14633&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M844.64 216.78h-57.78v699.59h57.78c29 0 52.5-23.51 52.5-52.5V269.28c0-28.99-23.51-52.5-52.5-52.5z&quot; fill=&quot;#D0E2F3&quot; p-id=&quot;14634&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.05 269.28V431.7h769.09V269.28c0-29-23.51-52.5-52.5-52.5H180.55c-29 0-52.5 23.51-52.5 52.5z&quot; fill=&quot;#EE8C98&quot; p-id=&quot;14635&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M897.14 431.7V269.28c0-29-23.51-52.5-52.5-52.5h-57.78V431.7h110.28z&quot; fill=&quot;#D96478&quot; p-id=&quot;14636&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M844.64 934.02H180.55c-38.68 0-70.14-31.47-70.14-70.14v-594.6c0-38.68 31.47-70.14 70.14-70.14h664.09c38.68 0 70.14 31.47 70.14 70.14v594.59c0 38.68-31.47 70.15-70.14 70.15z m-664.09-699.6c-19.22 0-34.86 15.64-34.86 34.86v594.59c0 19.22 15.64 34.86 34.86 34.86h664.09c19.22 0 34.86-15.64 34.86-34.86V269.28c0-19.22-15.64-34.86-34.86-34.86H180.55z&quot; fill=&quot;#49416F&quot; p-id=&quot;14637&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M897.14 449.34h-769.1c-9.74 0-17.64-7.9-17.64-17.64V269.28c0-38.68 31.47-70.14 70.14-70.14h664.09c38.68 0 70.14 31.47 70.14 70.14V431.7c0.01 9.74-7.89 17.64-17.63 17.64z m-751.45-35.28H879.5V269.28c0-19.22-15.64-34.86-34.86-34.86H180.55c-19.22 0-34.86 15.64-34.86 34.86v144.78z&quot; fill=&quot;#49416F&quot; p-id=&quot;14638&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M356.25 317.69h-73.86c-1.24 0-2.25-1.01-2.25-2.25V118.12c0-1.24 1.01-2.25 2.25-2.25h73.86c1.24 0 2.25 1.01 2.25 2.25v197.33c0 1.24-1.01 2.24-2.25 2.24zM705.87 317.69c-21.64 0-39.18-17.54-39.18-39.18V155.05c0-21.64 17.54-39.18 39.18-39.18s39.18 17.54 39.18 39.18v123.47c-0.01 21.63-17.55 39.17-39.18 39.17z&quot; fill=&quot;#A0C8EA&quot; p-id=&quot;14639&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M499.26 641.69c18.28 17.91 27.24 41.79 27.24 65.3s-8.96 47.39-27.24 65.67a92.988 92.988 0 0 1-65.67 27.24c-23.51 0-47.39-9.33-65.3-27.24-8.21-8.21-8.21-21.64 0-29.85s21.64-8.21 29.85 0c9.7 9.7 22.39 14.55 35.45 14.55 13.06 0 25.75-4.85 35.82-14.55 10.08-10.07 14.93-22.76 14.93-35.82 0-13.06-4.85-25.75-14.93-35.45-9.7-10.07-22.39-14.55-35.45-14.93-5.97 0.37-11.57-2.24-15.3-6.72-0.37 0-0.37 0-0.37-0.37-8.58-8.21-8.58-21.27-0.75-29.85l38.06-38.81h-60.45c-11.57 0-20.9-9.33-20.9-21.27 0-11.57 9.33-20.9 20.9-20.9h110.08c11.94 0 21.27 9.33 21.27 20.9 0 3.73-1.12 7.09-2.61 10.07-1.12 1.87-2.24 3.73-3.73 5.22l-47.02 48.51c9.7 4.49 18.66 10.46 26.12 18.3zM663.06 559.6v220.16c0 11.57-9.7 20.52-20.9 20.52-11.57 0-20.52-8.96-20.52-20.52v-183.6l-14.93 8.58c-3.36 2.24-7.09 2.99-10.45 2.99-7.09 0-13.81-3.73-17.54-10.45-6.34-9.33-2.98-22.39 6.72-27.99l45.9-27.24c0.37-0.37 1.12-0.37 1.49-0.75 0.75 0 1.12-0.75 1.87-1.12 0.75 0 1.49-0.37 2.24-0.37 0.37-0.37 1.12-0.37 1.49-0.37 0.75-0.37 1.87-0.37 2.61-0.37h4.1c0.37 0.37 1.12 0.37 1.49 0.37 1.12 0 1.49 0.37 2.24 0.75 0.37 0 1.12 0 1.49 0.37 1.12 0.75 1.49 1.12 2.24 1.12 0.37 0.37 0.75 0.75 1.49 1.12 0.37 0.37 1.12 0.75 1.49 1.12 0.75 0.37 1.12 1.12 1.49 1.49 0.37 0.37 0.75 0.75 1.12 1.49l1.49 1.49 0.37 0.75c0 0.37 0.37 0.75 0.37 1.12 0.37 0.75 0.75 1.12 0.75 1.86 0.37 0.75 0.37 1.49 0.75 1.87 0 0.75 0.37 1.49 0.37 1.87 0 1.12 0 1.86 0.75 2.61 0.02 0.38 0.02 0.75 0.02 1.13z&quot; fill=&quot;#49416F&quot; p-id=&quot;14640&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M319.32 335.33c-31.33 0-56.82-25.49-56.82-56.82V155.05c0-31.33 25.49-56.82 56.82-56.82s56.82 25.49 56.82 56.82v123.47c0 31.33-25.49 56.81-56.82 56.81z m0-201.82c-11.88 0-21.53 9.66-21.53 21.54v123.47c0 11.87 9.66 21.53 21.53 21.53s21.53-9.66 21.53-21.53V155.05c0-11.88-9.66-21.54-21.53-21.54zM705.87 335.33c-31.33 0-56.82-25.49-56.82-56.82V155.05c0-31.33 25.49-56.82 56.82-56.82 31.33 0 56.82 25.49 56.82 56.82v123.47c-0.01 31.33-25.49 56.81-56.82 56.81z m0-201.82c-11.88 0-21.53 9.66-21.53 21.54v123.47c0 11.87 9.66 21.53 21.53 21.53s21.53-9.66 21.53-21.53V155.05c0-11.88-9.66-21.54-21.53-21.54z&quot; fill=&quot;#49416F&quot; p-id=&quot;14641&quot;&gt;&lt;/path&gt;&lt;/svg&gt; default:category: &lt;svg t=&quot;1715526287939&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;25112&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M932.248101 989.414007H91.751899a4.791822 4.791822 0 0 1-4.738776-4.06686L0.053046 411.424782a4.791822 4.791822 0 0 1 4.738776-5.516784h1014.416356c2.935212 0 5.180826 2.616936 4.738776 5.516784l-86.960077 573.922365a4.791822 4.791822 0 0 1-4.738776 4.06686z&quot; fill=&quot;#F7B563&quot; p-id=&quot;25113&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M954.828015 405.907998V136.57577a13.579776 13.579776 0 0 0-13.579776-13.579776H396.695676a13.509048 13.509048 0 0 1-11.634756-6.595386l-45.142147-75.236911a13.61514 13.61514 0 0 0-11.634756-6.595386H84.307777A13.61514 13.61514 0 0 0 70.728001 48.165769v357.742229h884.100014z&quot; fill=&quot;#B5885B&quot; p-id=&quot;25114&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M123.774002 335.179997h778.008012v70.728001H123.774002z&quot; fill=&quot;#FFFFFF&quot; p-id=&quot;25115&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M141.456002 282.133996h742.644012v53.046001H141.456002z&quot; fill=&quot;#E7ECED&quot; p-id=&quot;25116&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M159.138002 229.087996h707.280012v53.046H159.138002z&quot; fill=&quot;#C7CAC7&quot; p-id=&quot;25117&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M42.083161 688.820003l14.23401 93.944467 93.944467-93.944467z&quot; fill=&quot;#424A60&quot; p-id=&quot;25118&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M200.266335 688.820003H150.261638l-93.944467 93.944467 6.577704 43.426993 9.707418 64.044205 201.433347-201.415665z&quot; fill=&quot;#EFCE4A&quot; p-id=&quot;25119&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M324.040337 688.820003h-50.004697L72.602293 890.235668l1.626744 10.768338h129.078602l212.184003-212.184003z&quot; fill=&quot;#424A60&quot; p-id=&quot;25120&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M465.496339 688.820003h-50.004697l-212.184003 212.184003h141.456002l212.184004-212.184003z&quot; fill=&quot;#EFCE4A&quot; p-id=&quot;25121&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M606.952341 688.820003h-50.004696l-212.184004 212.184003h141.456003l212.184003-212.184003z&quot; fill=&quot;#424A60&quot; p-id=&quot;25122&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M748.408344 688.820003h-50.004697l-212.184003 212.184003h141.456002l212.184003-212.184003z&quot; fill=&quot;#EFCE4A&quot; p-id=&quot;25123&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M889.864346 688.820003h-50.004697l-212.184003 212.184003h141.456002l212.184003-212.184003z&quot; fill=&quot;#424A60&quot; p-id=&quot;25124&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M981.315651 688.820003l-212.184003 212.184003h180.621633l23.34024-153.957176 8.823318-58.226827z&quot; fill=&quot;#EFCE4A&quot; p-id=&quot;25125&quot;&gt;&lt;/path&gt;&lt;/svg&gt; 代码块themes/Stellar/source/css/_common/highlight.styl所有代码注释。 https://prismjs.com/download.html 选择以下插件，保存JS文件至themes/Stellar/source/prism.js/下。 Show Language Highlight Keywords Toolbar Copy to Clipboard Button https://github.com/PrismJS/prism-themes/tree/master/themes themes/Stellar/source/prism.js/index.css /* keyword */ .token.keyword-for, .token.keyword-if, .token.keyword-else, .token.keyword-continue, .token.keyword-break, .token.keyword-return &#123; color: #c586c0; &#125; .token.keyword-void, .token.keyword-boolean, .token.keyword-short, .token.keyword-byte, .token.keyword-int, .token.keyword-long, .token.keyword-float, .token.keyword-double &#123; color: #4ec9b0; &#125; pre, code &#123; font-family: Monaco, Menlo, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace !important; font-size: 18px !important; &#125; pre code:not(.language-txt) &#123; color: #9cdcfe !important; &#125; @media screen and (max-width: 1439px) &#123; pre, code &#123; font-size: 16px !important; &#125; &#125; pre &#123; border: 1px solid #404040; border-radius: 12px; &#125; :not(pre)&gt;code &#123; padding: .1em .3em; font-size: unset !important; color: #db4c69; background: #1e1e1e; border: 1px solid #404040; border-radius: .3em; &#125; /* toolbar */ .code-toolbar &#123; position: relative; &#125; .code-toolbar .toolbar-item:last-child &#123; display: none !important; &#125; .code-toolbar:hover .toolbar-item:first-child &#123; display: none; &#125; .code-toolbar:hover .toolbar-item:last-child &#123; display: flex !important; &#125; .toolbar &#123; position: absolute; top: 8px; right: 8px; display: flex; &#125; .toolbar-item &#123; z-index: 1; display: flex; align-items: center; justify-content: center; height: 24px; border-radius: 5px; &#125; .toolbar-item:first-child &#123; background-color: #3a3a3a; &#125; .toolbar-item:last-child &#123; background-color: #7088ff; &#125; .toolbar-item:last-child:hover &#123; background-color: #8a9dff; &#125; .toolbar-item span &#123; padding-inline: 8px; font-size: 14px; font-family: Monaco, Menlo, Consolas, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, &quot;Courier New&quot;, monospace; color: white; &#125; .toolbar-item button &#123; width: 100%; height: 100%; padding: 0; font-family: unset; background-color: transparent; &#125; themes/Stellar/layout/_partial/head.ejs &lt;head&gt; ... &lt;link rel=&quot;stylesheet&quot; href=&quot;/prism.js/vscode-dark-plus.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/prism.js/index.css&quot; /&gt; &lt;/head&gt; themes/Stellar/layout/_partial/scripts.ejs &lt;script src=&quot;/prism.js/prism.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Prism.hooks.add(&quot;wrap&quot;, env =&gt; &#123; if (env.type === &quot;keyword&quot;) &#123; env.classes.push(&quot;keyword-&quot; + env.content); &#125; &#125;); &lt;/script&gt; 基本样式themes/Stellar/source/css/main.styl // 滚动条 ::-webkit-scrollbar width: 4px; height: 4px; ::-webkit-scrollbar-button width: 20px ::-webkit-scrollbar-thumb background-color: #8b8b8b; border-radius: 5px; // 超链接 li:not([class]) a:not([class]), p:not([class]) a:not([class]), table a:not([class]) transition: none // 消息提示 div.toast padding: 0.5rem 1rem .l_body .l_right --blur-bg: var(--alpha100) border: 1px solid var(--block-border) .l_main max-width: 850px !important margin-inline: auto padding-top: 8px // 悬浮按钮 .float-panel --blur-bg: var(--alpha100) !important border: 1px solid var(--block-border) box-shadow: 0 1px 2px 0px rgba(0, 0, 0, 0.1) button &amp;:hover background-color: var(--block-hover) &amp;:not(:first-child) border-top: 1px solid var(--block-border) .l_body[leftbar] .float-panel, .l_body[rightbar] .float-panel box-shadow: unset .l_body[leftbar] .float-panel button.leftbar-toggle, .l_body[rightbar] .float-panel button.rightbar-toggle background-color: #8a9dff // 分类视图 .post-list #cats a.cat.child padding-left: 2.5rem; // 标签 .post-list #tags a.tag:before content: &quot;&quot; // 归档超链接 .post-list #archive a.post border-bottom: 1px solid transparent // 文章详情卡片 .banner.top border-radius: 16px // 标题指示条 .md-text.content h1 font-weight: 500 a.headerlink:before content: &quot;:&quot; h2 a.headerlink:before content: &quot;&quot; // 继续阅读 #read-next .body border-top: 1px solid var(--block-border) border-bottom: 1px solid var(--block-border) .item border: none !important 响应式themes/Stellar/source/css/_defines/const.styl $device-mobile-max = 9999px $device-tablet = 9999px $device-laptop = 9999px 卡片themes/Stellar/source/css/_defines/func.styl floatable-float() box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1), 0 4px 16px rgba(0, 0, 0, 0.1) // transform: translate3d(0, -2px, 0) hoverable-card() ondark() &amp;:hover box-shadow: 0 0 0 1px $color-theme","categories":["Hexo","Stellar"]},{"title":"算法模板/图论","path":"/2024/05/04/算法/算法模板/图论/","content":"最短路class Dijkstra &#123; static long INF = Long.MAX_VALUE &gt;&gt; 1; static long[] run(List&lt;Pair&lt;Integer, Integer&gt;&gt;[] g, int s) &#123; Queue&lt;Pair&lt;Integer, Long&gt;&gt; q = new PriorityQueue&lt;&gt;(Comparator.comparingLong(Pair::getValue)); boolean[] vis = new boolean[g.length]; long[] dist = LongStream.range(0, g.length).map(_ -&gt; INF).toArray(); q.offer(new Pair&lt;&gt;(s, dist[s] = 0)); while (!q.isEmpty()) &#123; int u = q.poll().getKey(); if (vis[u]) &#123; continue; &#125; vis[u] = true; for (Pair&lt;Integer, Integer&gt; edge : g[u]) &#123; int v = edge.getKey(), w = edge.getValue(); long d = dist[u] + w; if (d &lt; dist[v]) &#123; q.offer(new Pair&lt;&gt;(v, dist[v] = d)); &#125; &#125; &#125; return Arrays.stream(dist).map(dist_i -&gt; dist_i == INF ? -1 : dist_i).toArray(); &#125; &#125; 最小生成树class Kruskal &#123; static long run(int n, int[][] edges) &#123; Arrays.sort(edges, Comparator.comparingInt(edge -&gt; edge[2])); UnionFindSet U = new UnionFindSet(n); int cnt = 0; long res = 0; for (int[] edge : edges) &#123; int x = U.find(edge[0]), y = U.find(edge[1]), w = edge[2]; if (U.merge(x, y)) &#123; ++cnt; res += w; if (cnt == n - 1) &#123; break; &#125; &#125; &#125; return res; &#125; &#125; 二分图判断class U &#123; static boolean dfs(List&lt;Integer&gt;[] e, int[] color, int u, int c) &#123; color[u] = c; for (int v : e[u]) &#123; if (color[v] &gt; 0) &#123; if (color[v] == c) &#123; return false; &#125; &#125; else if (!dfs(e, color, v, 3 - c)) &#123; return false; &#125; &#125; return true; &#125; static boolean valid(List&lt;Integer&gt;[] e) &#123; int n = e.length; int[] color = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; if (color[i] &gt; 0) &#123; continue; &#125; if (!dfs(e, color, i, 1)) &#123; return false; &#125; &#125; return true; &#125; &#125; 最大匹配class U &#123; static boolean dfs(List&lt;Integer&gt;[] e, int[] vis, int[] match, int u, int sgn) &#123; if (vis[u] == sgn) &#123; return false; &#125; vis[u] = sgn; for (int v : e[u]) &#123; if (match[v] == -1 || dfs(e, vis, match, match[v], sgn)) &#123; match[v] = u; return true; &#125; &#125; return false; &#125; static int pairs(List&lt;Integer&gt;[] e) &#123; int n = e.length; int[] vis = IntStream.range(0, n).map(_ -&gt; -1).toArray(), match = IntStream.range(0, n).map(_ -&gt; -1).toArray(); int res = 0; for (int i = 0; i &lt; n; ++i) &#123; if (dfs(e, vis, match, i, i)) &#123; ++res; &#125; &#125; return res; &#125; &#125; 欧拉路径class U &#123; static void dfs(List&lt;Integer&gt;[] e, List&lt;Integer&gt; path, int u) &#123; while (!e[u].isEmpty()) &#123; int v = path.get(path.size() - 1); path.remove(path.size() - 1); dfs(e, path, v); &#125; path.add(u); &#125; static List&lt;Integer&gt; run(List&lt;Integer&gt;[] e, int s) &#123; List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); dfs(e, path, s); Collections.reverse(path); return path; &#125; &#125; 网络流最大流class Edge &#123; int next, to, flow; Edge(int next, int to, int flow) &#123; this.next = next; this.to = to; this.flow = flow; &#125; &#125; class Maxflow &#123; int INF = Integer.MAX_VALUE &gt;&gt; 1; Edge[] g; int index = 1, source, destination; int[] head, cur, depth; Maxflow(int n, int m, int source, int destination) &#123; g = new Edge[(m + 5) &lt;&lt; 1]; this.source = source; this.destination = destination; head = new int[n + 5]; cur = new int[n + 5]; depth = new int[n + 5]; &#125; void add(int u, int v, int flow) &#123; g[++index] = new Edge(head[u], v, flow); head[u] = index; &#125; void addedge(int u, int v, int flow) &#123; add(u, v, flow); add(v, u, 0); &#125; boolean bfs() &#123; Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(List.of(source)); cur[source] = head[source]; Arrays.fill(depth, INF); depth[source] = 0; while (!q.isEmpty()) &#123; int u = q.poll(); if (u == destination) &#123; return true; &#125; for (int i = head[u]; i &gt; 0; i = g[i].next) &#123; int v = g[i].to, w = g[i].flow; if (w &gt; 0 &amp;&amp; depth[v] == INF) &#123; cur[v] = head[v]; depth[v] = depth[u] + 1; q.offer(v); &#125; &#125; &#125; return false; &#125; int dfs(int u, int flow) &#123; if (u == destination) &#123; return flow; &#125; int res = 0; for (int i = cur[u]; i &gt; 0; i = g[i].next) &#123; cur[u] = i; int v = g[i].to, w = g[i].flow; if (w &gt; 0 &amp;&amp; depth[u] + 1 == depth[v]) &#123; int k = dfs(v, Math.min(flow, w)); g[i].flow -= k; g[i ^ 1].flow += k; res += k; if (res == flow) &#123; break; &#125; &#125; &#125; return res; &#125; int run() &#123; int maxflow = 0; while (bfs()) &#123; maxflow += dfs(source, INF); &#125; return maxflow; &#125; &#125; 最小费用最大流class Edge &#123; int next, to, flow, cost; Edge(int next, int to, int flow, int cost) &#123; this.next = next; this.to = to; this.flow = flow; this.cost = cost; &#125; &#125; class Mincostflow &#123; int INF = Integer.MAX_VALUE &gt;&gt; 1; Edge[] g; int index = 1, source, destination; int[] head, cur; boolean[] vis; long[] dist; Mincostflow(int n, int m, int source, int destination) &#123; g = new Edge[(m + 5) &lt;&lt; 1]; this.source = source; this.destination = destination; head = new int[n + 5]; cur = new int[n + 5]; vis = new boolean[n + 5]; dist = new long[n + 5]; &#125; void add(int u, int v, int flow, int cost) &#123; g[++index] = new Edge(head[u], v, flow, cost); head[u] = index; &#125; void addedge(int u, int v, int flow, int cost) &#123; add(u, v, flow, cost); add(v, u, 0, -cost); &#125; boolean bfs() &#123; Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(List.of(source)); cur = Arrays.copyOf(head, head.length); Arrays.fill(dist, INF); dist[source] = 0; while (!q.isEmpty()) &#123; int u = q.poll(); vis[u] = false; for (int i = head[u]; i &gt; 0; i = g[i].next) &#123; int v = g[i].to, w = g[i].flow; long d = dist[u] + g[i].cost; if (w &gt; 0 &amp;&amp; d &lt; dist[v]) &#123; dist[v] = d; if (!vis[v]) &#123; vis[v] = true; q.offer(v); &#125; &#125; &#125; &#125; return dist[destination] != INF; &#125; int dfs(int u, int flow) &#123; if (u == destination) &#123; return flow; &#125; vis[u] = true; int res = flow; for (int i = head[u]; i &gt; 0; i = g[i].next) &#123; cur[u] = i; int v = g[i].to, w = g[i].flow; long d = dist[u] + g[i].cost; if (w &gt; 0 &amp;&amp; !vis[v] &amp;&amp; d == dist[v]) &#123; int k = dfs(v, Math.min(res, w)); g[i].flow -= k; g[i ^ 1].flow += k; res -= k; &#125; &#125; vis[u] = false; return flow - res; &#125; Pair&lt;Long, Integer&gt; run() &#123; long mincost = 0; int maxflow = 0; while (bfs()) &#123; int flow = dfs(source, INF); maxflow += flow; mincost += dist[destination] * flow; &#125; return new Pair&lt;&gt;(mincost, maxflow); &#125; &#125;","categories":["算法模板","图论"]}]